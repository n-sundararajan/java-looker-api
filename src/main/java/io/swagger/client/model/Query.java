/*
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Query
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-06-08T15:12:41.902+05:30")
public class Query {
  @SerializedName("id")
  private Long id = null;

  @SerializedName("model")
  private String model = null;

  @SerializedName("view")
  private String view = null;

  @SerializedName("fields")
  private List<String> fields = null;

  @SerializedName("pivots")
  private List<String> pivots = null;

  @SerializedName("fill_fields")
  private List<String> fillFields = null;

  @SerializedName("filters")
  private Map<String, String> filters = null;

  @SerializedName("filter_expression")
  private String filterExpression = null;

  @SerializedName("sorts")
  private List<String> sorts = null;

  @SerializedName("limit")
  private String limit = null;

  @SerializedName("column_limit")
  private String columnLimit = null;

  @SerializedName("total")
  private Boolean total = null;

  @SerializedName("row_total")
  private String rowTotal = null;

  @SerializedName("runtime")
  private Double runtime = null;

  @SerializedName("vis_config")
  private Map<String, String> visConfig = null;

  @SerializedName("filter_config")
  private Map<String, String> filterConfig = null;

  @SerializedName("visible_ui_sections")
  private String visibleUiSections = null;

  @SerializedName("slug")
  private String slug = null;

  @SerializedName("dynamic_fields")
  private List<String> dynamicFields = null;

  @SerializedName("client_id")
  private String clientId = null;

  @SerializedName("share_url")
  private String shareUrl = null;

  @SerializedName("expanded_share_url")
  private String expandedShareUrl = null;

  @SerializedName("url")
  private String url = null;

  @SerializedName("query_timezone")
  private String queryTimezone = null;

  @SerializedName("has_table_calculations")
  private Boolean hasTableCalculations = null;

  @SerializedName("can")
  private Map<String, Boolean> can = null;

   /**
   * Unique Id
   * @return id
  **/
  @ApiModelProperty(value = "Unique Id")
  public Long getId() {
    return id;
  }

  public Query model(String model) {
    this.model = model;
    return this;
  }

   /**
   * Model
   * @return model
  **/
  @ApiModelProperty(required = true, value = "Model")
  public String getModel() {
    return model;
  }

  public void setModel(String model) {
    this.model = model;
  }

  public Query view(String view) {
    this.view = view;
    return this;
  }

   /**
   * View
   * @return view
  **/
  @ApiModelProperty(required = true, value = "View")
  public String getView() {
    return view;
  }

  public void setView(String view) {
    this.view = view;
  }

  public Query fields(List<String> fields) {
    this.fields = fields;
    return this;
  }

  public Query addFieldsItem(String fieldsItem) {
    if (this.fields == null) {
      this.fields = new ArrayList<String>();
    }
    this.fields.add(fieldsItem);
    return this;
  }

   /**
   * Fields
   * @return fields
  **/
  @ApiModelProperty(value = "Fields")
  public List<String> getFields() {
    return fields;
  }

  public void setFields(List<String> fields) {
    this.fields = fields;
  }

  public Query pivots(List<String> pivots) {
    this.pivots = pivots;
    return this;
  }

  public Query addPivotsItem(String pivotsItem) {
    if (this.pivots == null) {
      this.pivots = new ArrayList<String>();
    }
    this.pivots.add(pivotsItem);
    return this;
  }

   /**
   * Pivots
   * @return pivots
  **/
  @ApiModelProperty(value = "Pivots")
  public List<String> getPivots() {
    return pivots;
  }

  public void setPivots(List<String> pivots) {
    this.pivots = pivots;
  }

  public Query fillFields(List<String> fillFields) {
    this.fillFields = fillFields;
    return this;
  }

  public Query addFillFieldsItem(String fillFieldsItem) {
    if (this.fillFields == null) {
      this.fillFields = new ArrayList<String>();
    }
    this.fillFields.add(fillFieldsItem);
    return this;
  }

   /**
   * Fill Fields
   * @return fillFields
  **/
  @ApiModelProperty(value = "Fill Fields")
  public List<String> getFillFields() {
    return fillFields;
  }

  public void setFillFields(List<String> fillFields) {
    this.fillFields = fillFields;
  }

  public Query filters(Map<String, String> filters) {
    this.filters = filters;
    return this;
  }

  public Query putFiltersItem(String key, String filtersItem) {
    if (this.filters == null) {
      this.filters = new HashMap<String, String>();
    }
    this.filters.put(key, filtersItem);
    return this;
  }

   /**
   * Filters
   * @return filters
  **/
  @ApiModelProperty(value = "Filters")
  public Map<String, String> getFilters() {
    return filters;
  }

  public void setFilters(Map<String, String> filters) {
    this.filters = filters;
  }

  public Query filterExpression(String filterExpression) {
    this.filterExpression = filterExpression;
    return this;
  }

   /**
   * Filter Expression
   * @return filterExpression
  **/
  @ApiModelProperty(value = "Filter Expression")
  public String getFilterExpression() {
    return filterExpression;
  }

  public void setFilterExpression(String filterExpression) {
    this.filterExpression = filterExpression;
  }

  public Query sorts(List<String> sorts) {
    this.sorts = sorts;
    return this;
  }

  public Query addSortsItem(String sortsItem) {
    if (this.sorts == null) {
      this.sorts = new ArrayList<String>();
    }
    this.sorts.add(sortsItem);
    return this;
  }

   /**
   * Sorts
   * @return sorts
  **/
  @ApiModelProperty(value = "Sorts")
  public List<String> getSorts() {
    return sorts;
  }

  public void setSorts(List<String> sorts) {
    this.sorts = sorts;
  }

  public Query limit(String limit) {
    this.limit = limit;
    return this;
  }

   /**
   * Limit
   * @return limit
  **/
  @ApiModelProperty(value = "Limit")
  public String getLimit() {
    return limit;
  }

  public void setLimit(String limit) {
    this.limit = limit;
  }

  public Query columnLimit(String columnLimit) {
    this.columnLimit = columnLimit;
    return this;
  }

   /**
   * Column Limit
   * @return columnLimit
  **/
  @ApiModelProperty(value = "Column Limit")
  public String getColumnLimit() {
    return columnLimit;
  }

  public void setColumnLimit(String columnLimit) {
    this.columnLimit = columnLimit;
  }

  public Query total(Boolean total) {
    this.total = total;
    return this;
  }

   /**
   * Total
   * @return total
  **/
  @ApiModelProperty(value = "Total")
  public Boolean isTotal() {
    return total;
  }

  public void setTotal(Boolean total) {
    this.total = total;
  }

  public Query rowTotal(String rowTotal) {
    this.rowTotal = rowTotal;
    return this;
  }

   /**
   * Raw Total
   * @return rowTotal
  **/
  @ApiModelProperty(value = "Raw Total")
  public String getRowTotal() {
    return rowTotal;
  }

  public void setRowTotal(String rowTotal) {
    this.rowTotal = rowTotal;
  }

  public Query runtime(Double runtime) {
    this.runtime = runtime;
    return this;
  }

   /**
   * Runtime
   * @return runtime
  **/
  @ApiModelProperty(value = "Runtime")
  public Double getRuntime() {
    return runtime;
  }

  public void setRuntime(Double runtime) {
    this.runtime = runtime;
  }

  public Query visConfig(Map<String, String> visConfig) {
    this.visConfig = visConfig;
    return this;
  }

  public Query putVisConfigItem(String key, String visConfigItem) {
    if (this.visConfig == null) {
      this.visConfig = new HashMap<String, String>();
    }
    this.visConfig.put(key, visConfigItem);
    return this;
  }

   /**
   * Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A \&quot;type\&quot; key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.
   * @return visConfig
  **/
  @ApiModelProperty(value = "Visualization configuration properties. These properties are typically opaque and differ based on the type of visualization used. There is no specified set of allowed keys. The values can be any type supported by JSON. A \"type\" key with a string value is often present, and is used by Looker to determine which visualization to present. Visualizations ignore unknown vis_config properties.")
  public Map<String, String> getVisConfig() {
    return visConfig;
  }

  public void setVisConfig(Map<String, String> visConfig) {
    this.visConfig = visConfig;
  }

  public Query filterConfig(Map<String, String> filterConfig) {
    this.filterConfig = filterConfig;
    return this;
  }

  public Query putFilterConfigItem(String key, String filterConfigItem) {
    if (this.filterConfig == null) {
      this.filterConfig = new HashMap<String, String>();
    }
    this.filterConfig.put(key, filterConfigItem);
    return this;
  }

   /**
   * The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over \&quot;filters\&quot;. When creating a query or modifying an existing query, \&quot;filter_config\&quot; should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.
   * @return filterConfig
  **/
  @ApiModelProperty(value = "The filter_config represents the state of the filter UI on the explore page for a given query. When running a query via the Looker UI, this parameter takes precedence over \"filters\". When creating a query or modifying an existing query, \"filter_config\" should be set to null. Setting it to any other value could cause unexpected filtering behavior. The format should be considered opaque.")
  public Map<String, String> getFilterConfig() {
    return filterConfig;
  }

  public void setFilterConfig(Map<String, String> filterConfig) {
    this.filterConfig = filterConfig;
  }

  public Query visibleUiSections(String visibleUiSections) {
    this.visibleUiSections = visibleUiSections;
    return this;
  }

   /**
   * Visible UI Sections
   * @return visibleUiSections
  **/
  @ApiModelProperty(value = "Visible UI Sections")
  public String getVisibleUiSections() {
    return visibleUiSections;
  }

  public void setVisibleUiSections(String visibleUiSections) {
    this.visibleUiSections = visibleUiSections;
  }

   /**
   * Slug
   * @return slug
  **/
  @ApiModelProperty(value = "Slug")
  public String getSlug() {
    return slug;
  }

  public Query dynamicFields(List<String> dynamicFields) {
    this.dynamicFields = dynamicFields;
    return this;
  }

  public Query addDynamicFieldsItem(String dynamicFieldsItem) {
    if (this.dynamicFields == null) {
      this.dynamicFields = new ArrayList<String>();
    }
    this.dynamicFields.add(dynamicFieldsItem);
    return this;
  }

   /**
   * Dynamic Fields
   * @return dynamicFields
  **/
  @ApiModelProperty(value = "Dynamic Fields")
  public List<String> getDynamicFields() {
    return dynamicFields;
  }

  public void setDynamicFields(List<String> dynamicFields) {
    this.dynamicFields = dynamicFields;
  }

  public Query clientId(String clientId) {
    this.clientId = clientId;
    return this;
  }

   /**
   * Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.
   * @return clientId
  **/
  @ApiModelProperty(value = "Client Id: used to generate shortened explore URLs. If set by client, must be a unique 22 character alphanumeric string. Otherwise one will be generated.")
  public String getClientId() {
    return clientId;
  }

  public void setClientId(String clientId) {
    this.clientId = clientId;
  }

   /**
   * Share Url
   * @return shareUrl
  **/
  @ApiModelProperty(value = "Share Url")
  public String getShareUrl() {
    return shareUrl;
  }

   /**
   * Expanded Share Url
   * @return expandedShareUrl
  **/
  @ApiModelProperty(value = "Expanded Share Url")
  public String getExpandedShareUrl() {
    return expandedShareUrl;
  }

   /**
   * Expanded Url
   * @return url
  **/
  @ApiModelProperty(value = "Expanded Url")
  public String getUrl() {
    return url;
  }

  public Query queryTimezone(String queryTimezone) {
    this.queryTimezone = queryTimezone;
    return this;
  }

   /**
   * Query Timezone
   * @return queryTimezone
  **/
  @ApiModelProperty(value = "Query Timezone")
  public String getQueryTimezone() {
    return queryTimezone;
  }

  public void setQueryTimezone(String queryTimezone) {
    this.queryTimezone = queryTimezone;
  }

   /**
   * Has Table Calculations
   * @return hasTableCalculations
  **/
  @ApiModelProperty(value = "Has Table Calculations")
  public Boolean isHasTableCalculations() {
    return hasTableCalculations;
  }

  public Query can(Map<String, Boolean> can) {
    this.can = can;
    return this;
  }

  public Query putCanItem(String key, Boolean canItem) {
    if (this.can == null) {
      this.can = new HashMap<String, Boolean>();
    }
    this.can.put(key, canItem);
    return this;
  }

   /**
   * Operations the current user is able to perform on this object
   * @return can
  **/
  @ApiModelProperty(value = "Operations the current user is able to perform on this object")
  public Map<String, Boolean> getCan() {
    return can;
  }

  public void setCan(Map<String, Boolean> can) {
    this.can = can;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Query query = (Query) o;
    return Objects.equals(this.id, query.id) &&
        Objects.equals(this.model, query.model) &&
        Objects.equals(this.view, query.view) &&
        Objects.equals(this.fields, query.fields) &&
        Objects.equals(this.pivots, query.pivots) &&
        Objects.equals(this.fillFields, query.fillFields) &&
        Objects.equals(this.filters, query.filters) &&
        Objects.equals(this.filterExpression, query.filterExpression) &&
        Objects.equals(this.sorts, query.sorts) &&
        Objects.equals(this.limit, query.limit) &&
        Objects.equals(this.columnLimit, query.columnLimit) &&
        Objects.equals(this.total, query.total) &&
        Objects.equals(this.rowTotal, query.rowTotal) &&
        Objects.equals(this.runtime, query.runtime) &&
        Objects.equals(this.visConfig, query.visConfig) &&
        Objects.equals(this.filterConfig, query.filterConfig) &&
        Objects.equals(this.visibleUiSections, query.visibleUiSections) &&
        Objects.equals(this.slug, query.slug) &&
        Objects.equals(this.dynamicFields, query.dynamicFields) &&
        Objects.equals(this.clientId, query.clientId) &&
        Objects.equals(this.shareUrl, query.shareUrl) &&
        Objects.equals(this.expandedShareUrl, query.expandedShareUrl) &&
        Objects.equals(this.url, query.url) &&
        Objects.equals(this.queryTimezone, query.queryTimezone) &&
        Objects.equals(this.hasTableCalculations, query.hasTableCalculations) &&
        Objects.equals(this.can, query.can);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, model, view, fields, pivots, fillFields, filters, filterExpression, sorts, limit, columnLimit, total, rowTotal, runtime, visConfig, filterConfig, visibleUiSections, slug, dynamicFields, clientId, shareUrl, expandedShareUrl, url, queryTimezone, hasTableCalculations, can);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Query {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    view: ").append(toIndentedString(view)).append("\n");
    sb.append("    fields: ").append(toIndentedString(fields)).append("\n");
    sb.append("    pivots: ").append(toIndentedString(pivots)).append("\n");
    sb.append("    fillFields: ").append(toIndentedString(fillFields)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    filterExpression: ").append(toIndentedString(filterExpression)).append("\n");
    sb.append("    sorts: ").append(toIndentedString(sorts)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    columnLimit: ").append(toIndentedString(columnLimit)).append("\n");
    sb.append("    total: ").append(toIndentedString(total)).append("\n");
    sb.append("    rowTotal: ").append(toIndentedString(rowTotal)).append("\n");
    sb.append("    runtime: ").append(toIndentedString(runtime)).append("\n");
    sb.append("    visConfig: ").append(toIndentedString(visConfig)).append("\n");
    sb.append("    filterConfig: ").append(toIndentedString(filterConfig)).append("\n");
    sb.append("    visibleUiSections: ").append(toIndentedString(visibleUiSections)).append("\n");
    sb.append("    slug: ").append(toIndentedString(slug)).append("\n");
    sb.append("    dynamicFields: ").append(toIndentedString(dynamicFields)).append("\n");
    sb.append("    clientId: ").append(toIndentedString(clientId)).append("\n");
    sb.append("    shareUrl: ").append(toIndentedString(shareUrl)).append("\n");
    sb.append("    expandedShareUrl: ").append(toIndentedString(expandedShareUrl)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    queryTimezone: ").append(toIndentedString(queryTimezone)).append("\n");
    sb.append("    hasTableCalculations: ").append(toIndentedString(hasTableCalculations)).append("\n");
    sb.append("    can: ").append(toIndentedString(can)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

