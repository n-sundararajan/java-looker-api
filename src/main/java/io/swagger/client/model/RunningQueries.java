/*
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.LookBasic;
import io.swagger.client.model.Query;
import io.swagger.client.model.SqlQuery;
import io.swagger.client.model.UserPublic;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * RunningQueries
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-06-08T15:12:41.902+05:30")
public class RunningQueries {
  @SerializedName("id")
  private Long id = null;

  @SerializedName("user")
  private UserPublic user = null;

  @SerializedName("query")
  private Query query = null;

  @SerializedName("sql_query")
  private SqlQuery sqlQuery = null;

  @SerializedName("look")
  private LookBasic look = null;

  @SerializedName("created_at")
  private String createdAt = null;

  @SerializedName("completed_at")
  private String completedAt = null;

  @SerializedName("query_id")
  private String queryId = null;

  @SerializedName("source")
  private String source = null;

  @SerializedName("node_id")
  private String nodeId = null;

  @SerializedName("slug")
  private String slug = null;

  @SerializedName("query_task_id")
  private String queryTaskId = null;

  @SerializedName("cache_key")
  private String cacheKey = null;

  @SerializedName("connection_name")
  private String connectionName = null;

  @SerializedName("dialect")
  private String dialect = null;

  @SerializedName("connection_id")
  private String connectionId = null;

  @SerializedName("message")
  private String message = null;

  @SerializedName("status")
  private String status = null;

  @SerializedName("runtime")
  private Double runtime = null;

  @SerializedName("sql")
  private String sql = null;

  @SerializedName("can")
  private Map<String, Boolean> can = null;

   /**
   * Unique Id
   * @return id
  **/
  @ApiModelProperty(value = "Unique Id")
  public Long getId() {
    return id;
  }

  public RunningQueries user(UserPublic user) {
    this.user = user;
    return this;
  }

   /**
   * User who initiated the query
   * @return user
  **/
  @ApiModelProperty(value = "User who initiated the query")
  public UserPublic getUser() {
    return user;
  }

  public void setUser(UserPublic user) {
    this.user = user;
  }

  public RunningQueries query(Query query) {
    this.query = query;
    return this;
  }

   /**
   * Query that was run
   * @return query
  **/
  @ApiModelProperty(value = "Query that was run")
  public Query getQuery() {
    return query;
  }

  public void setQuery(Query query) {
    this.query = query;
  }

  public RunningQueries sqlQuery(SqlQuery sqlQuery) {
    this.sqlQuery = sqlQuery;
    return this;
  }

   /**
   * SQL Query that was run
   * @return sqlQuery
  **/
  @ApiModelProperty(value = "SQL Query that was run")
  public SqlQuery getSqlQuery() {
    return sqlQuery;
  }

  public void setSqlQuery(SqlQuery sqlQuery) {
    this.sqlQuery = sqlQuery;
  }

  public RunningQueries look(LookBasic look) {
    this.look = look;
    return this;
  }

   /**
   * Look of query that was run
   * @return look
  **/
  @ApiModelProperty(value = "Look of query that was run")
  public LookBasic getLook() {
    return look;
  }

  public void setLook(LookBasic look) {
    this.look = look;
  }

   /**
   * Date/Time Query was initiated
   * @return createdAt
  **/
  @ApiModelProperty(value = "Date/Time Query was initiated")
  public String getCreatedAt() {
    return createdAt;
  }

   /**
   * Date/Time Query was completed
   * @return completedAt
  **/
  @ApiModelProperty(value = "Date/Time Query was completed")
  public String getCompletedAt() {
    return completedAt;
  }

   /**
   * Query Id
   * @return queryId
  **/
  @ApiModelProperty(value = "Query Id")
  public String getQueryId() {
    return queryId;
  }

   /**
   * Source (look, dashboard, queryrunner, explore, etc.)
   * @return source
  **/
  @ApiModelProperty(value = "Source (look, dashboard, queryrunner, explore, etc.)")
  public String getSource() {
    return source;
  }

   /**
   * Node Id
   * @return nodeId
  **/
  @ApiModelProperty(value = "Node Id")
  public String getNodeId() {
    return nodeId;
  }

   /**
   * Slug
   * @return slug
  **/
  @ApiModelProperty(value = "Slug")
  public String getSlug() {
    return slug;
  }

   /**
   * ID of a Query Task
   * @return queryTaskId
  **/
  @ApiModelProperty(value = "ID of a Query Task")
  public String getQueryTaskId() {
    return queryTaskId;
  }

   /**
   * Cache Key
   * @return cacheKey
  **/
  @ApiModelProperty(value = "Cache Key")
  public String getCacheKey() {
    return cacheKey;
  }

   /**
   * Connection
   * @return connectionName
  **/
  @ApiModelProperty(value = "Connection")
  public String getConnectionName() {
    return connectionName;
  }

   /**
   * Dialect
   * @return dialect
  **/
  @ApiModelProperty(value = "Dialect")
  public String getDialect() {
    return dialect;
  }

   /**
   * Connection ID
   * @return connectionId
  **/
  @ApiModelProperty(value = "Connection ID")
  public String getConnectionId() {
    return connectionId;
  }

   /**
   * Additional Information(Error message or verbose status)
   * @return message
  **/
  @ApiModelProperty(value = "Additional Information(Error message or verbose status)")
  public String getMessage() {
    return message;
  }

   /**
   * Status description
   * @return status
  **/
  @ApiModelProperty(value = "Status description")
  public String getStatus() {
    return status;
  }

   /**
   * Number of seconds elapsed running the Query
   * @return runtime
  **/
  @ApiModelProperty(value = "Number of seconds elapsed running the Query")
  public Double getRuntime() {
    return runtime;
  }

   /**
   * SQL text of the query as run
   * @return sql
  **/
  @ApiModelProperty(value = "SQL text of the query as run")
  public String getSql() {
    return sql;
  }

  public RunningQueries can(Map<String, Boolean> can) {
    this.can = can;
    return this;
  }

  public RunningQueries putCanItem(String key, Boolean canItem) {
    if (this.can == null) {
      this.can = new HashMap<String, Boolean>();
    }
    this.can.put(key, canItem);
    return this;
  }

   /**
   * Operations the current user is able to perform on this object
   * @return can
  **/
  @ApiModelProperty(value = "Operations the current user is able to perform on this object")
  public Map<String, Boolean> getCan() {
    return can;
  }

  public void setCan(Map<String, Boolean> can) {
    this.can = can;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RunningQueries runningQueries = (RunningQueries) o;
    return Objects.equals(this.id, runningQueries.id) &&
        Objects.equals(this.user, runningQueries.user) &&
        Objects.equals(this.query, runningQueries.query) &&
        Objects.equals(this.sqlQuery, runningQueries.sqlQuery) &&
        Objects.equals(this.look, runningQueries.look) &&
        Objects.equals(this.createdAt, runningQueries.createdAt) &&
        Objects.equals(this.completedAt, runningQueries.completedAt) &&
        Objects.equals(this.queryId, runningQueries.queryId) &&
        Objects.equals(this.source, runningQueries.source) &&
        Objects.equals(this.nodeId, runningQueries.nodeId) &&
        Objects.equals(this.slug, runningQueries.slug) &&
        Objects.equals(this.queryTaskId, runningQueries.queryTaskId) &&
        Objects.equals(this.cacheKey, runningQueries.cacheKey) &&
        Objects.equals(this.connectionName, runningQueries.connectionName) &&
        Objects.equals(this.dialect, runningQueries.dialect) &&
        Objects.equals(this.connectionId, runningQueries.connectionId) &&
        Objects.equals(this.message, runningQueries.message) &&
        Objects.equals(this.status, runningQueries.status) &&
        Objects.equals(this.runtime, runningQueries.runtime) &&
        Objects.equals(this.sql, runningQueries.sql) &&
        Objects.equals(this.can, runningQueries.can);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, user, query, sqlQuery, look, createdAt, completedAt, queryId, source, nodeId, slug, queryTaskId, cacheKey, connectionName, dialect, connectionId, message, status, runtime, sql, can);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RunningQueries {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    user: ").append(toIndentedString(user)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    sqlQuery: ").append(toIndentedString(sqlQuery)).append("\n");
    sb.append("    look: ").append(toIndentedString(look)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    completedAt: ").append(toIndentedString(completedAt)).append("\n");
    sb.append("    queryId: ").append(toIndentedString(queryId)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    nodeId: ").append(toIndentedString(nodeId)).append("\n");
    sb.append("    slug: ").append(toIndentedString(slug)).append("\n");
    sb.append("    queryTaskId: ").append(toIndentedString(queryTaskId)).append("\n");
    sb.append("    cacheKey: ").append(toIndentedString(cacheKey)).append("\n");
    sb.append("    connectionName: ").append(toIndentedString(connectionName)).append("\n");
    sb.append("    dialect: ").append(toIndentedString(dialect)).append("\n");
    sb.append("    connectionId: ").append(toIndentedString(connectionId)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    runtime: ").append(toIndentedString(runtime)).append("\n");
    sb.append("    sql: ").append(toIndentedString(sql)).append("\n");
    sb.append("    can: ").append(toIndentedString(can)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

