/*
 * Looker API 3.0 Reference
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning) 
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.swagger.client.model.CreateQueryTask;
import io.swagger.client.model.Error;
import io.swagger.client.model.Query;
import io.swagger.client.model.QueryTask;
import io.swagger.client.model.ValidationError;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class QueryApi {
    private ApiClient apiClient;

    public QueryApi() {
        this(Configuration.getDefaultApiClient());
    }

    public QueryApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createQuery
     * @param body Query (optional)
     * @param fields Requested fields. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call createQueryCall(Query body, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/queries";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (fields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("fields", fields));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createQueryValidateBeforeCall(Query body, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = createQueryCall(body, fields, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Create Query
     * ### Create a query.  This allows you to create a new query that you can later run. Looker queries are immutable once created and are not deleted. If you create a query that is exactly like an existing query then the existing query will be returned and no new query will be created. Whether a new query is created or not, you can use the &#39;id&#39; in the returned query with the &#39;run&#39; method.  The query parameters are passed as json in the body of the request.  
     * @param body Query (optional)
     * @param fields Requested fields. (optional)
     * @return Query
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Query createQuery(Query body, String fields) throws ApiException {
        ApiResponse<Query> resp = createQueryWithHttpInfo(body, fields);
        return resp.getData();
    }

    /**
     * Create Query
     * ### Create a query.  This allows you to create a new query that you can later run. Looker queries are immutable once created and are not deleted. If you create a query that is exactly like an existing query then the existing query will be returned and no new query will be created. Whether a new query is created or not, you can use the &#39;id&#39; in the returned query with the &#39;run&#39; method.  The query parameters are passed as json in the body of the request.  
     * @param body Query (optional)
     * @param fields Requested fields. (optional)
     * @return ApiResponse&lt;Query&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Query> createQueryWithHttpInfo(Query body, String fields) throws ApiException {
        com.squareup.okhttp.Call call = createQueryValidateBeforeCall(body, fields, null, null);
        Type localVarReturnType = new TypeToken<Query>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create Query (asynchronously)
     * ### Create a query.  This allows you to create a new query that you can later run. Looker queries are immutable once created and are not deleted. If you create a query that is exactly like an existing query then the existing query will be returned and no new query will be created. Whether a new query is created or not, you can use the &#39;id&#39; in the returned query with the &#39;run&#39; method.  The query parameters are passed as json in the body of the request.  
     * @param body Query (optional)
     * @param fields Requested fields. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createQueryAsync(Query body, String fields, final ApiCallback<Query> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createQueryValidateBeforeCall(body, fields, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Query>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for createQueryTask
     * @param body Query parameters (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param fields Requested fields (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call createQueryTaskCall(CreateQueryTask body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/query_tasks";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (applyFormatting != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apply_formatting", applyFormatting));
        if (applyVis != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apply_vis", applyVis));
        if (cache != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cache", cache));
        if (imageWidth != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("image_width", imageWidth));
        if (imageHeight != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("image_height", imageHeight));
        if (generateDrillLinks != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("generate_drill_links", generateDrillLinks));
        if (forceProduction != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force_production", forceProduction));
        if (cacheOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cache_only", cacheOnly));
        if (pathPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path_prefix", pathPrefix));
        if (rebuildPdts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("rebuild_pdts", rebuildPdts));
        if (serverTableCalcs != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("server_table_calcs", serverTableCalcs));
        if (fields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("fields", fields));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createQueryTaskValidateBeforeCall(CreateQueryTask body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createQueryTask(Async)");
        }
        

        com.squareup.okhttp.Call call = createQueryTaskCall(body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, fields, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Run Query Async
     * ### Run a saved query asynchronously.  Runs a previously created query asynchronously. Returns a Query Task ID which can be used to fetch the results from the Query Tasks results endpoint. 
     * @param body Query parameters (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param fields Requested fields (optional)
     * @return QueryTask
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public QueryTask createQueryTask(CreateQueryTask body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, String fields) throws ApiException {
        ApiResponse<QueryTask> resp = createQueryTaskWithHttpInfo(body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, fields);
        return resp.getData();
    }

    /**
     * Run Query Async
     * ### Run a saved query asynchronously.  Runs a previously created query asynchronously. Returns a Query Task ID which can be used to fetch the results from the Query Tasks results endpoint. 
     * @param body Query parameters (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param fields Requested fields (optional)
     * @return ApiResponse&lt;QueryTask&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<QueryTask> createQueryTaskWithHttpInfo(CreateQueryTask body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, String fields) throws ApiException {
        com.squareup.okhttp.Call call = createQueryTaskValidateBeforeCall(body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, fields, null, null);
        Type localVarReturnType = new TypeToken<QueryTask>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Run Query Async (asynchronously)
     * ### Run a saved query asynchronously.  Runs a previously created query asynchronously. Returns a Query Task ID which can be used to fetch the results from the Query Tasks results endpoint. 
     * @param body Query parameters (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param fields Requested fields (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createQueryTaskAsync(CreateQueryTask body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, String fields, final ApiCallback<QueryTask> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createQueryTaskValidateBeforeCall(body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, fields, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<QueryTask>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for query
     * @param queryId Id of query (required)
     * @param fields Requested fields. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call queryCall(Long queryId, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/queries/{query_id}"
            .replaceAll("\\{" + "query_id" + "\\}", apiClient.escapeString(queryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (fields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("fields", fields));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call queryValidateBeforeCall(Long queryId, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'queryId' is set
        if (queryId == null) {
            throw new ApiException("Missing the required parameter 'queryId' when calling query(Async)");
        }
        

        com.squareup.okhttp.Call call = queryCall(queryId, fields, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get Query
     * ### Get a previously created query by id.  A Looker query object includes the various parameters that define a database query that has been run or could be run in the future. These parameters include: model, view, fields, filters, pivots, etc. Query *results* are not part of the query object.  Query objects are unique and immutable. Query objects are created automatically in Looker as users explore data. Looker does not delete them; they become part of the query history. When asked to create a query for any given set of parameters, Looker will first try to find an existing query object with matching parameters and will only create a new object when an appropriate object can not be found.  This &#39;get&#39; method is used to get the details about a query for a given id. See the other methods here to &#39;create&#39; and &#39;run&#39; queries.  Note that some fields like &#39;filter_config&#39; and &#39;vis_config&#39; etc are specific to how the Looker UI builds queries and visualizations and are not generally useful for API use. They are not required when creating new queries and can usually just be ignored.  
     * @param queryId Id of query (required)
     * @param fields Requested fields. (optional)
     * @return Query
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Query query(Long queryId, String fields) throws ApiException {
        ApiResponse<Query> resp = queryWithHttpInfo(queryId, fields);
        return resp.getData();
    }

    /**
     * Get Query
     * ### Get a previously created query by id.  A Looker query object includes the various parameters that define a database query that has been run or could be run in the future. These parameters include: model, view, fields, filters, pivots, etc. Query *results* are not part of the query object.  Query objects are unique and immutable. Query objects are created automatically in Looker as users explore data. Looker does not delete them; they become part of the query history. When asked to create a query for any given set of parameters, Looker will first try to find an existing query object with matching parameters and will only create a new object when an appropriate object can not be found.  This &#39;get&#39; method is used to get the details about a query for a given id. See the other methods here to &#39;create&#39; and &#39;run&#39; queries.  Note that some fields like &#39;filter_config&#39; and &#39;vis_config&#39; etc are specific to how the Looker UI builds queries and visualizations and are not generally useful for API use. They are not required when creating new queries and can usually just be ignored.  
     * @param queryId Id of query (required)
     * @param fields Requested fields. (optional)
     * @return ApiResponse&lt;Query&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Query> queryWithHttpInfo(Long queryId, String fields) throws ApiException {
        com.squareup.okhttp.Call call = queryValidateBeforeCall(queryId, fields, null, null);
        Type localVarReturnType = new TypeToken<Query>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Query (asynchronously)
     * ### Get a previously created query by id.  A Looker query object includes the various parameters that define a database query that has been run or could be run in the future. These parameters include: model, view, fields, filters, pivots, etc. Query *results* are not part of the query object.  Query objects are unique and immutable. Query objects are created automatically in Looker as users explore data. Looker does not delete them; they become part of the query history. When asked to create a query for any given set of parameters, Looker will first try to find an existing query object with matching parameters and will only create a new object when an appropriate object can not be found.  This &#39;get&#39; method is used to get the details about a query for a given id. See the other methods here to &#39;create&#39; and &#39;run&#39; queries.  Note that some fields like &#39;filter_config&#39; and &#39;vis_config&#39; etc are specific to how the Looker UI builds queries and visualizations and are not generally useful for API use. They are not required when creating new queries and can usually just be ignored.  
     * @param queryId Id of query (required)
     * @param fields Requested fields. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call queryAsync(Long queryId, String fields, final ApiCallback<Query> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = queryValidateBeforeCall(queryId, fields, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Query>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for queryForSlug
     * @param slug Slug of query (required)
     * @param fields Requested fields. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call queryForSlugCall(String slug, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/queries/slug/{slug}"
            .replaceAll("\\{" + "slug" + "\\}", apiClient.escapeString(slug.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (fields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("fields", fields));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call queryForSlugValidateBeforeCall(String slug, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'slug' is set
        if (slug == null) {
            throw new ApiException("Missing the required parameter 'slug' when calling queryForSlug(Async)");
        }
        

        com.squareup.okhttp.Call call = queryForSlugCall(slug, fields, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get Query for Slug
     * ### Get the query for a given query slug.  This returns the query for the &#39;slug&#39; in a query share URL.  The &#39;slug&#39; is a randomly chosen short string that is used as an alternative to the query&#39;s id value for use in URLs etc. This method exists as a convenience to help you use the API to &#39;find&#39; queries that have been created using the Looker UI.  You can use the Looker explore page to build a query and then choose the &#39;Share&#39; option to show the share url for the query. Share urls generally look something like &#39;https://looker.yourcompany/x/vwGSbfc&#39;. The trailing &#39;vwGSbfc&#39; is the share slug. You can pass that string to this api method to get details about the query. Those details include the &#39;id&#39; that you can use to run the query. Or, you can copy the query body (perhaps with your own modification) and use that as the basis to make/run new queries.  This will also work with slugs from Looker explore urls like &#39;https://looker.yourcompany/explore/ecommerce/orders?qid&#x3D;aogBgL6o3cKK1jN3RoZl5s&#39;. In this case &#39;aogBgL6o3cKK1jN3RoZl5s&#39; is the slug. 
     * @param slug Slug of query (required)
     * @param fields Requested fields. (optional)
     * @return Query
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Query queryForSlug(String slug, String fields) throws ApiException {
        ApiResponse<Query> resp = queryForSlugWithHttpInfo(slug, fields);
        return resp.getData();
    }

    /**
     * Get Query for Slug
     * ### Get the query for a given query slug.  This returns the query for the &#39;slug&#39; in a query share URL.  The &#39;slug&#39; is a randomly chosen short string that is used as an alternative to the query&#39;s id value for use in URLs etc. This method exists as a convenience to help you use the API to &#39;find&#39; queries that have been created using the Looker UI.  You can use the Looker explore page to build a query and then choose the &#39;Share&#39; option to show the share url for the query. Share urls generally look something like &#39;https://looker.yourcompany/x/vwGSbfc&#39;. The trailing &#39;vwGSbfc&#39; is the share slug. You can pass that string to this api method to get details about the query. Those details include the &#39;id&#39; that you can use to run the query. Or, you can copy the query body (perhaps with your own modification) and use that as the basis to make/run new queries.  This will also work with slugs from Looker explore urls like &#39;https://looker.yourcompany/explore/ecommerce/orders?qid&#x3D;aogBgL6o3cKK1jN3RoZl5s&#39;. In this case &#39;aogBgL6o3cKK1jN3RoZl5s&#39; is the slug. 
     * @param slug Slug of query (required)
     * @param fields Requested fields. (optional)
     * @return ApiResponse&lt;Query&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Query> queryForSlugWithHttpInfo(String slug, String fields) throws ApiException {
        com.squareup.okhttp.Call call = queryForSlugValidateBeforeCall(slug, fields, null, null);
        Type localVarReturnType = new TypeToken<Query>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Query for Slug (asynchronously)
     * ### Get the query for a given query slug.  This returns the query for the &#39;slug&#39; in a query share URL.  The &#39;slug&#39; is a randomly chosen short string that is used as an alternative to the query&#39;s id value for use in URLs etc. This method exists as a convenience to help you use the API to &#39;find&#39; queries that have been created using the Looker UI.  You can use the Looker explore page to build a query and then choose the &#39;Share&#39; option to show the share url for the query. Share urls generally look something like &#39;https://looker.yourcompany/x/vwGSbfc&#39;. The trailing &#39;vwGSbfc&#39; is the share slug. You can pass that string to this api method to get details about the query. Those details include the &#39;id&#39; that you can use to run the query. Or, you can copy the query body (perhaps with your own modification) and use that as the basis to make/run new queries.  This will also work with slugs from Looker explore urls like &#39;https://looker.yourcompany/explore/ecommerce/orders?qid&#x3D;aogBgL6o3cKK1jN3RoZl5s&#39;. In this case &#39;aogBgL6o3cKK1jN3RoZl5s&#39; is the slug. 
     * @param slug Slug of query (required)
     * @param fields Requested fields. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call queryForSlugAsync(String slug, String fields, final ApiCallback<Query> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = queryForSlugValidateBeforeCall(slug, fields, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Query>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for queryTask
     * @param queryTaskId ID of the Query Task (required)
     * @param fields Requested fields. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call queryTaskCall(String queryTaskId, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/query_tasks/{query_task_id}"
            .replaceAll("\\{" + "query_task_id" + "\\}", apiClient.escapeString(queryTaskId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (fields != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("fields", fields));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call queryTaskValidateBeforeCall(String queryTaskId, String fields, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'queryTaskId' is set
        if (queryTaskId == null) {
            throw new ApiException("Missing the required parameter 'queryTaskId' when calling queryTask(Async)");
        }
        

        com.squareup.okhttp.Call call = queryTaskCall(queryTaskId, fields, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get Async Query Info
     * Returns information about a Query Task.  Query Tasks are generated by running queries asynchronously. They are represented by a GUID returned from one of the async query endpoints. 
     * @param queryTaskId ID of the Query Task (required)
     * @param fields Requested fields. (optional)
     * @return QueryTask
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public QueryTask queryTask(String queryTaskId, String fields) throws ApiException {
        ApiResponse<QueryTask> resp = queryTaskWithHttpInfo(queryTaskId, fields);
        return resp.getData();
    }

    /**
     * Get Async Query Info
     * Returns information about a Query Task.  Query Tasks are generated by running queries asynchronously. They are represented by a GUID returned from one of the async query endpoints. 
     * @param queryTaskId ID of the Query Task (required)
     * @param fields Requested fields. (optional)
     * @return ApiResponse&lt;QueryTask&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<QueryTask> queryTaskWithHttpInfo(String queryTaskId, String fields) throws ApiException {
        com.squareup.okhttp.Call call = queryTaskValidateBeforeCall(queryTaskId, fields, null, null);
        Type localVarReturnType = new TypeToken<QueryTask>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Async Query Info (asynchronously)
     * Returns information about a Query Task.  Query Tasks are generated by running queries asynchronously. They are represented by a GUID returned from one of the async query endpoints. 
     * @param queryTaskId ID of the Query Task (required)
     * @param fields Requested fields. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call queryTaskAsync(String queryTaskId, String fields, final ApiCallback<QueryTask> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = queryTaskValidateBeforeCall(queryTaskId, fields, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<QueryTask>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for queryTaskMultiResults
     * @param queryTaskIds List of Query Task IDs (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call queryTaskMultiResultsCall(List<String> queryTaskIds, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/query_tasks/multi_results";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (queryTaskIds != null)
        localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("csv", "query_task_ids", queryTaskIds));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call queryTaskMultiResultsValidateBeforeCall(List<String> queryTaskIds, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'queryTaskIds' is set
        if (queryTaskIds == null) {
            throw new ApiException("Missing the required parameter 'queryTaskIds' when calling queryTaskMultiResults(Async)");
        }
        

        com.squareup.okhttp.Call call = queryTaskMultiResultsCall(queryTaskIds, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get Multiple Async Query Results
     * Fetch the results of multiple async Query Tasks in one response.  Query Tasks that are not ready will be skipped and will not appear in the response. Query Tasks whose results have expired will have a status of &#39;expired&#39;. If the user making the API request does not have sufficient privileges to view a Query Task result, the result will have a status of &#39;missing&#39; 
     * @param queryTaskIds List of Query Task IDs (required)
     * @return Map&lt;String, String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Map<String, String> queryTaskMultiResults(List<String> queryTaskIds) throws ApiException {
        ApiResponse<Map<String, String>> resp = queryTaskMultiResultsWithHttpInfo(queryTaskIds);
        return resp.getData();
    }

    /**
     * Get Multiple Async Query Results
     * Fetch the results of multiple async Query Tasks in one response.  Query Tasks that are not ready will be skipped and will not appear in the response. Query Tasks whose results have expired will have a status of &#39;expired&#39;. If the user making the API request does not have sufficient privileges to view a Query Task result, the result will have a status of &#39;missing&#39; 
     * @param queryTaskIds List of Query Task IDs (required)
     * @return ApiResponse&lt;Map&lt;String, String&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Map<String, String>> queryTaskMultiResultsWithHttpInfo(List<String> queryTaskIds) throws ApiException {
        com.squareup.okhttp.Call call = queryTaskMultiResultsValidateBeforeCall(queryTaskIds, null, null);
        Type localVarReturnType = new TypeToken<Map<String, String>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Multiple Async Query Results (asynchronously)
     * Fetch the results of multiple async Query Tasks in one response.  Query Tasks that are not ready will be skipped and will not appear in the response. Query Tasks whose results have expired will have a status of &#39;expired&#39;. If the user making the API request does not have sufficient privileges to view a Query Task result, the result will have a status of &#39;missing&#39; 
     * @param queryTaskIds List of Query Task IDs (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call queryTaskMultiResultsAsync(List<String> queryTaskIds, final ApiCallback<Map<String, String>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = queryTaskMultiResultsValidateBeforeCall(queryTaskIds, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Map<String, String>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for queryTaskResults
     * @param queryTaskId ID of the Query Task (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call queryTaskResultsCall(String queryTaskId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/query_tasks/{query_task_id}/results"
            .replaceAll("\\{" + "query_task_id" + "\\}", apiClient.escapeString(queryTaskId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text", "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call queryTaskResultsValidateBeforeCall(String queryTaskId, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'queryTaskId' is set
        if (queryTaskId == null) {
            throw new ApiException("Missing the required parameter 'queryTaskId' when calling queryTaskResults(Async)");
        }
        

        com.squareup.okhttp.Call call = queryTaskResultsCall(queryTaskId, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Get Async Query Results
     * Returns the results of an async Query Task if the query has completed. 
     * @param queryTaskId ID of the Query Task (required)
     * @return Map&lt;String, String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Map<String, String> queryTaskResults(String queryTaskId) throws ApiException {
        ApiResponse<Map<String, String>> resp = queryTaskResultsWithHttpInfo(queryTaskId);
        return resp.getData();
    }

    /**
     * Get Async Query Results
     * Returns the results of an async Query Task if the query has completed. 
     * @param queryTaskId ID of the Query Task (required)
     * @return ApiResponse&lt;Map&lt;String, String&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Map<String, String>> queryTaskResultsWithHttpInfo(String queryTaskId) throws ApiException {
        com.squareup.okhttp.Call call = queryTaskResultsValidateBeforeCall(queryTaskId, null, null);
        Type localVarReturnType = new TypeToken<Map<String, String>>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Get Async Query Results (asynchronously)
     * Returns the results of an async Query Task if the query has completed. 
     * @param queryTaskId ID of the Query Task (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call queryTaskResultsAsync(String queryTaskId, final ApiCallback<Map<String, String>> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = queryTaskResultsValidateBeforeCall(queryTaskId, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Map<String, String>>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for runInlineQuery
     * @param resultFormat Format of result (required)
     * @param body inline query (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call runInlineQueryCall(String resultFormat, Query body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/queries/run/{result_format}"
            .replaceAll("\\{" + "result_format" + "\\}", apiClient.escapeString(resultFormat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (applyFormatting != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apply_formatting", applyFormatting));
        if (applyVis != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apply_vis", applyVis));
        if (cache != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cache", cache));
        if (imageWidth != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("image_width", imageWidth));
        if (imageHeight != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("image_height", imageHeight));
        if (generateDrillLinks != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("generate_drill_links", generateDrillLinks));
        if (forceProduction != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force_production", forceProduction));
        if (cacheOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cache_only", cacheOnly));
        if (pathPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path_prefix", pathPrefix));
        if (rebuildPdts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("rebuild_pdts", rebuildPdts));
        if (serverTableCalcs != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("server_table_calcs", serverTableCalcs));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text", "application/json", "image/png", "image/jpg"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call runInlineQueryValidateBeforeCall(String resultFormat, Query body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'resultFormat' is set
        if (resultFormat == null) {
            throw new ApiException("Missing the required parameter 'resultFormat' when calling runInlineQuery(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling runInlineQuery(Async)");
        }
        

        com.squareup.okhttp.Call call = runInlineQueryCall(resultFormat, body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Run Inline Query
     * ### Run the query that is specified inline in the posted body.  This allows running a query as defined in json in the posted body. This combines the two actions of posting &amp; running a query into one step.  Here is an example body in json: &#x60;&#x60;&#x60; {   \&quot;model\&quot;:\&quot;thelook\&quot;,   \&quot;view\&quot;:\&quot;inventory_items\&quot;,   \&quot;fields\&quot;:[\&quot;category.name\&quot;,\&quot;inventory_items.days_in_inventory_tier\&quot;,\&quot;products.count\&quot;],   \&quot;filters\&quot;:{\&quot;category.name\&quot;:\&quot;socks\&quot;},   \&quot;sorts\&quot;:[\&quot;products.count desc 0\&quot;],   \&quot;limit\&quot;:\&quot;500\&quot;,   \&quot;query_timezone\&quot;:\&quot;America/Los_Angeles\&quot; } &#x60;&#x60;&#x60;  When using the Ruby SDK this would be passed as a Ruby hash like: &#x60;&#x60;&#x60; {  :model&#x3D;&gt;\&quot;thelook\&quot;,  :view&#x3D;&gt;\&quot;inventory_items\&quot;,  :fields&#x3D;&gt;   [\&quot;category.name\&quot;,    \&quot;inventory_items.days_in_inventory_tier\&quot;,    \&quot;products.count\&quot;],  :filters&#x3D;&gt;{:\&quot;category.name\&quot;&#x3D;&gt;\&quot;socks\&quot;},  :sorts&#x3D;&gt;[\&quot;products.count desc 0\&quot;],  :limit&#x3D;&gt;\&quot;500\&quot;,  :query_timezone&#x3D;&gt;\&quot;America/Los_Angeles\&quot;, } &#x60;&#x60;&#x60;  This will return the result of running the query in the format specified by the &#39;result_format&#39; parameter.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param resultFormat Format of result (required)
     * @param body inline query (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String runInlineQuery(String resultFormat, Query body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs) throws ApiException {
        ApiResponse<String> resp = runInlineQueryWithHttpInfo(resultFormat, body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs);
        return resp.getData();
    }

    /**
     * Run Inline Query
     * ### Run the query that is specified inline in the posted body.  This allows running a query as defined in json in the posted body. This combines the two actions of posting &amp; running a query into one step.  Here is an example body in json: &#x60;&#x60;&#x60; {   \&quot;model\&quot;:\&quot;thelook\&quot;,   \&quot;view\&quot;:\&quot;inventory_items\&quot;,   \&quot;fields\&quot;:[\&quot;category.name\&quot;,\&quot;inventory_items.days_in_inventory_tier\&quot;,\&quot;products.count\&quot;],   \&quot;filters\&quot;:{\&quot;category.name\&quot;:\&quot;socks\&quot;},   \&quot;sorts\&quot;:[\&quot;products.count desc 0\&quot;],   \&quot;limit\&quot;:\&quot;500\&quot;,   \&quot;query_timezone\&quot;:\&quot;America/Los_Angeles\&quot; } &#x60;&#x60;&#x60;  When using the Ruby SDK this would be passed as a Ruby hash like: &#x60;&#x60;&#x60; {  :model&#x3D;&gt;\&quot;thelook\&quot;,  :view&#x3D;&gt;\&quot;inventory_items\&quot;,  :fields&#x3D;&gt;   [\&quot;category.name\&quot;,    \&quot;inventory_items.days_in_inventory_tier\&quot;,    \&quot;products.count\&quot;],  :filters&#x3D;&gt;{:\&quot;category.name\&quot;&#x3D;&gt;\&quot;socks\&quot;},  :sorts&#x3D;&gt;[\&quot;products.count desc 0\&quot;],  :limit&#x3D;&gt;\&quot;500\&quot;,  :query_timezone&#x3D;&gt;\&quot;America/Los_Angeles\&quot;, } &#x60;&#x60;&#x60;  This will return the result of running the query in the format specified by the &#39;result_format&#39; parameter.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param resultFormat Format of result (required)
     * @param body inline query (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> runInlineQueryWithHttpInfo(String resultFormat, Query body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs) throws ApiException {
        com.squareup.okhttp.Call call = runInlineQueryValidateBeforeCall(resultFormat, body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Run Inline Query (asynchronously)
     * ### Run the query that is specified inline in the posted body.  This allows running a query as defined in json in the posted body. This combines the two actions of posting &amp; running a query into one step.  Here is an example body in json: &#x60;&#x60;&#x60; {   \&quot;model\&quot;:\&quot;thelook\&quot;,   \&quot;view\&quot;:\&quot;inventory_items\&quot;,   \&quot;fields\&quot;:[\&quot;category.name\&quot;,\&quot;inventory_items.days_in_inventory_tier\&quot;,\&quot;products.count\&quot;],   \&quot;filters\&quot;:{\&quot;category.name\&quot;:\&quot;socks\&quot;},   \&quot;sorts\&quot;:[\&quot;products.count desc 0\&quot;],   \&quot;limit\&quot;:\&quot;500\&quot;,   \&quot;query_timezone\&quot;:\&quot;America/Los_Angeles\&quot; } &#x60;&#x60;&#x60;  When using the Ruby SDK this would be passed as a Ruby hash like: &#x60;&#x60;&#x60; {  :model&#x3D;&gt;\&quot;thelook\&quot;,  :view&#x3D;&gt;\&quot;inventory_items\&quot;,  :fields&#x3D;&gt;   [\&quot;category.name\&quot;,    \&quot;inventory_items.days_in_inventory_tier\&quot;,    \&quot;products.count\&quot;],  :filters&#x3D;&gt;{:\&quot;category.name\&quot;&#x3D;&gt;\&quot;socks\&quot;},  :sorts&#x3D;&gt;[\&quot;products.count desc 0\&quot;],  :limit&#x3D;&gt;\&quot;500\&quot;,  :query_timezone&#x3D;&gt;\&quot;America/Los_Angeles\&quot;, } &#x60;&#x60;&#x60;  This will return the result of running the query in the format specified by the &#39;result_format&#39; parameter.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param resultFormat Format of result (required)
     * @param body inline query (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call runInlineQueryAsync(String resultFormat, Query body, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = runInlineQueryValidateBeforeCall(resultFormat, body, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for runQuery
     * @param queryId Id of query (required)
     * @param resultFormat Format of result (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call runQueryCall(Long queryId, String resultFormat, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/queries/{query_id}/run/{result_format}"
            .replaceAll("\\{" + "query_id" + "\\}", apiClient.escapeString(queryId.toString()))
            .replaceAll("\\{" + "result_format" + "\\}", apiClient.escapeString(resultFormat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (limit != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
        if (applyFormatting != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apply_formatting", applyFormatting));
        if (applyVis != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("apply_vis", applyVis));
        if (cache != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cache", cache));
        if (imageWidth != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("image_width", imageWidth));
        if (imageHeight != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("image_height", imageHeight));
        if (generateDrillLinks != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("generate_drill_links", generateDrillLinks));
        if (forceProduction != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force_production", forceProduction));
        if (cacheOnly != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("cache_only", cacheOnly));
        if (pathPrefix != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path_prefix", pathPrefix));
        if (rebuildPdts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("rebuild_pdts", rebuildPdts));
        if (serverTableCalcs != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("server_table_calcs", serverTableCalcs));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text", "application/json", "image/png", "image/jpg"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call runQueryValidateBeforeCall(Long queryId, String resultFormat, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'queryId' is set
        if (queryId == null) {
            throw new ApiException("Missing the required parameter 'queryId' when calling runQuery(Async)");
        }
        
        // verify the required parameter 'resultFormat' is set
        if (resultFormat == null) {
            throw new ApiException("Missing the required parameter 'resultFormat' when calling runQuery(Async)");
        }
        

        com.squareup.okhttp.Call call = runQueryCall(queryId, resultFormat, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Run Query
     * ### Run a saved query.  This runs a previously saved query. You can use this on a query that was generated in the Looker UI or one that you have explicitly created using the API. You can also use a query &#39;id&#39; from a saved &#39;Look&#39;.  The &#39;result_format&#39; parameter specifies the desired structure and format of the response.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param queryId Id of query (required)
     * @param resultFormat Format of result (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String runQuery(Long queryId, String resultFormat, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs) throws ApiException {
        ApiResponse<String> resp = runQueryWithHttpInfo(queryId, resultFormat, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs);
        return resp.getData();
    }

    /**
     * Run Query
     * ### Run a saved query.  This runs a previously saved query. You can use this on a query that was generated in the Looker UI or one that you have explicitly created using the API. You can also use a query &#39;id&#39; from a saved &#39;Look&#39;.  The &#39;result_format&#39; parameter specifies the desired structure and format of the response.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param queryId Id of query (required)
     * @param resultFormat Format of result (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> runQueryWithHttpInfo(Long queryId, String resultFormat, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs) throws ApiException {
        com.squareup.okhttp.Call call = runQueryValidateBeforeCall(queryId, resultFormat, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Run Query (asynchronously)
     * ### Run a saved query.  This runs a previously saved query. You can use this on a query that was generated in the Looker UI or one that you have explicitly created using the API. You can also use a query &#39;id&#39; from a saved &#39;Look&#39;.  The &#39;result_format&#39; parameter specifies the desired structure and format of the response.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param queryId Id of query (required)
     * @param resultFormat Format of result (required)
     * @param limit Row limit (may override the limit in the saved query). (optional)
     * @param applyFormatting Apply model-specified formatting to each result. (optional)
     * @param applyVis Apply visualization options to results. (optional)
     * @param cache Get results from cache if available. (optional)
     * @param imageWidth Render width for image formats. (optional)
     * @param imageHeight Render height for image formats. (optional)
     * @param generateDrillLinks Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param forceProduction Force use of production models even if the user is in development mode. (optional)
     * @param cacheOnly Retrieve any results from cache even if the results have expired. (optional)
     * @param pathPrefix Prefix to use for drill links (url encoded). (optional)
     * @param rebuildPdts Rebuild PDTS used in query. (optional)
     * @param serverTableCalcs Perform table calculations on query results (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call runQueryAsync(Long queryId, String resultFormat, Long limit, Boolean applyFormatting, Boolean applyVis, Boolean cache, Long imageWidth, Long imageHeight, Boolean generateDrillLinks, Boolean forceProduction, Boolean cacheOnly, String pathPrefix, Boolean rebuildPdts, Boolean serverTableCalcs, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = runQueryValidateBeforeCall(queryId, resultFormat, limit, applyFormatting, applyVis, cache, imageWidth, imageHeight, generateDrillLinks, forceProduction, cacheOnly, pathPrefix, rebuildPdts, serverTableCalcs, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for runUrlEncodedQuery
     * @param modelName Model name (required)
     * @param viewName View name (required)
     * @param resultFormat Format of result (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call runUrlEncodedQueryCall(String modelName, String viewName, String resultFormat, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/queries/models/{model_name}/views/{view_name}/run/{result_format}"
            .replaceAll("\\{" + "model_name" + "\\}", apiClient.escapeString(modelName.toString()))
            .replaceAll("\\{" + "view_name" + "\\}", apiClient.escapeString(viewName.toString()))
            .replaceAll("\\{" + "result_format" + "\\}", apiClient.escapeString(resultFormat.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text", "application/json", "image/png", "image/jpg"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call runUrlEncodedQueryValidateBeforeCall(String modelName, String viewName, String resultFormat, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'modelName' is set
        if (modelName == null) {
            throw new ApiException("Missing the required parameter 'modelName' when calling runUrlEncodedQuery(Async)");
        }
        
        // verify the required parameter 'viewName' is set
        if (viewName == null) {
            throw new ApiException("Missing the required parameter 'viewName' when calling runUrlEncodedQuery(Async)");
        }
        
        // verify the required parameter 'resultFormat' is set
        if (resultFormat == null) {
            throw new ApiException("Missing the required parameter 'resultFormat' when calling runUrlEncodedQuery(Async)");
        }
        

        com.squareup.okhttp.Call call = runUrlEncodedQueryCall(modelName, viewName, resultFormat, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Run Url Encoded Query
     * ### Run an URL encoded query.  This requires the caller to encode the specifiers for the query into the URL query part using Looker-specific syntax as explained below.  Generally, you would want to use one of the methods that takes the parameters as json in the POST body for creating and/or running queries. This method exists for cases where one really needs to encode the parameters into the URL of a single &#39;GET&#39; request. This matches the way that the Looker UI formats &#39;explore&#39; URLs etc.  The parameters here are very similar to the json body formatting except that the filter syntax is tricky. Unfortunately, this format makes this method not currently callible via the &#39;Try it out!&#39; button in this documentation page. But, this is callable  when creating URLs manually or when using the Looker SDK.  Here is an example inline query URL:  &#x60;&#x60;&#x60; https://looker.mycompany.com:19999/api/3.0/queries/models/thelook/views/inventory_items/run/json?fields&#x3D;category.name,inventory_items.days_in_inventory_tier,products.count&amp;f[category.name]&#x3D;socks&amp;sorts&#x3D;products.count+desc+0&amp;limit&#x3D;500&amp;query_timezone&#x3D;America/Los_Angeles &#x60;&#x60;&#x60;  When invoking this endpoint with the Ruby SDK, pass the query parameter parts as a hash. The hash to match the above would look like:  &#x60;&#x60;&#x60;ruby query_params &#x3D; {   :fields &#x3D;&gt; \&quot;category.name,inventory_items.days_in_inventory_tier,products.count\&quot;,   :\&quot;f[category.name]\&quot; &#x3D;&gt; \&quot;socks\&quot;,   :sorts &#x3D;&gt; \&quot;products.count desc 0\&quot;,   :limit &#x3D;&gt; \&quot;500\&quot;,   :query_timezone &#x3D;&gt; \&quot;America/Los_Angeles\&quot; } response &#x3D; ruby_sdk.run_url_encoded_query(&#39;thelook&#39;,&#39;inventory_items&#39;,&#39;json&#39;, query_params)  &#x60;&#x60;&#x60;  Again, it is generally easier to use the variant of this method that passes the full query in the POST body. This method is available for cases where other alternatives won&#39;t fit the need.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param modelName Model name (required)
     * @param viewName View name (required)
     * @param resultFormat Format of result (required)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String runUrlEncodedQuery(String modelName, String viewName, String resultFormat) throws ApiException {
        ApiResponse<String> resp = runUrlEncodedQueryWithHttpInfo(modelName, viewName, resultFormat);
        return resp.getData();
    }

    /**
     * Run Url Encoded Query
     * ### Run an URL encoded query.  This requires the caller to encode the specifiers for the query into the URL query part using Looker-specific syntax as explained below.  Generally, you would want to use one of the methods that takes the parameters as json in the POST body for creating and/or running queries. This method exists for cases where one really needs to encode the parameters into the URL of a single &#39;GET&#39; request. This matches the way that the Looker UI formats &#39;explore&#39; URLs etc.  The parameters here are very similar to the json body formatting except that the filter syntax is tricky. Unfortunately, this format makes this method not currently callible via the &#39;Try it out!&#39; button in this documentation page. But, this is callable  when creating URLs manually or when using the Looker SDK.  Here is an example inline query URL:  &#x60;&#x60;&#x60; https://looker.mycompany.com:19999/api/3.0/queries/models/thelook/views/inventory_items/run/json?fields&#x3D;category.name,inventory_items.days_in_inventory_tier,products.count&amp;f[category.name]&#x3D;socks&amp;sorts&#x3D;products.count+desc+0&amp;limit&#x3D;500&amp;query_timezone&#x3D;America/Los_Angeles &#x60;&#x60;&#x60;  When invoking this endpoint with the Ruby SDK, pass the query parameter parts as a hash. The hash to match the above would look like:  &#x60;&#x60;&#x60;ruby query_params &#x3D; {   :fields &#x3D;&gt; \&quot;category.name,inventory_items.days_in_inventory_tier,products.count\&quot;,   :\&quot;f[category.name]\&quot; &#x3D;&gt; \&quot;socks\&quot;,   :sorts &#x3D;&gt; \&quot;products.count desc 0\&quot;,   :limit &#x3D;&gt; \&quot;500\&quot;,   :query_timezone &#x3D;&gt; \&quot;America/Los_Angeles\&quot; } response &#x3D; ruby_sdk.run_url_encoded_query(&#39;thelook&#39;,&#39;inventory_items&#39;,&#39;json&#39;, query_params)  &#x60;&#x60;&#x60;  Again, it is generally easier to use the variant of this method that passes the full query in the POST body. This method is available for cases where other alternatives won&#39;t fit the need.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param modelName Model name (required)
     * @param viewName View name (required)
     * @param resultFormat Format of result (required)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> runUrlEncodedQueryWithHttpInfo(String modelName, String viewName, String resultFormat) throws ApiException {
        com.squareup.okhttp.Call call = runUrlEncodedQueryValidateBeforeCall(modelName, viewName, resultFormat, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Run Url Encoded Query (asynchronously)
     * ### Run an URL encoded query.  This requires the caller to encode the specifiers for the query into the URL query part using Looker-specific syntax as explained below.  Generally, you would want to use one of the methods that takes the parameters as json in the POST body for creating and/or running queries. This method exists for cases where one really needs to encode the parameters into the URL of a single &#39;GET&#39; request. This matches the way that the Looker UI formats &#39;explore&#39; URLs etc.  The parameters here are very similar to the json body formatting except that the filter syntax is tricky. Unfortunately, this format makes this method not currently callible via the &#39;Try it out!&#39; button in this documentation page. But, this is callable  when creating URLs manually or when using the Looker SDK.  Here is an example inline query URL:  &#x60;&#x60;&#x60; https://looker.mycompany.com:19999/api/3.0/queries/models/thelook/views/inventory_items/run/json?fields&#x3D;category.name,inventory_items.days_in_inventory_tier,products.count&amp;f[category.name]&#x3D;socks&amp;sorts&#x3D;products.count+desc+0&amp;limit&#x3D;500&amp;query_timezone&#x3D;America/Los_Angeles &#x60;&#x60;&#x60;  When invoking this endpoint with the Ruby SDK, pass the query parameter parts as a hash. The hash to match the above would look like:  &#x60;&#x60;&#x60;ruby query_params &#x3D; {   :fields &#x3D;&gt; \&quot;category.name,inventory_items.days_in_inventory_tier,products.count\&quot;,   :\&quot;f[category.name]\&quot; &#x3D;&gt; \&quot;socks\&quot;,   :sorts &#x3D;&gt; \&quot;products.count desc 0\&quot;,   :limit &#x3D;&gt; \&quot;500\&quot;,   :query_timezone &#x3D;&gt; \&quot;America/Los_Angeles\&quot; } response &#x3D; ruby_sdk.run_url_encoded_query(&#39;thelook&#39;,&#39;inventory_items&#39;,&#39;json&#39;, query_params)  &#x60;&#x60;&#x60;  Again, it is generally easier to use the variant of this method that passes the full query in the POST body. This method is available for cases where other alternatives won&#39;t fit the need.  Suported formats:  | result_format | Description | :-----------: | :--- | | json | Plain json | json_detail | Row data plus metadata describing the fields, pivots, table calcs, and other aspects of the query | csv | Comma separated values with a header | txt | Tab separated values with a header | html | Simple html | md | Simple markdown | xlsx | MS Excel spreadsheet | sql | Returns the generated SQL rather than running the query | png | A PNG image of the visualization of the query | jpg | A JPG image of the visualization of the query   
     * @param modelName Model name (required)
     * @param viewName View name (required)
     * @param resultFormat Format of result (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call runUrlEncodedQueryAsync(String modelName, String viewName, String resultFormat, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = runUrlEncodedQueryValidateBeforeCall(modelName, viewName, resultFormat, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
